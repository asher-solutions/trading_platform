Full stack algorithmic trading platform:

The key concept is that in a hybrid architecture, rather than choosing between client-first or server-first at the project level, we choose it at the page level.

For some pages—login, static content, simple UIs—we rely primarily on a server-first setup and let Django carry the load. For other pages where we need a complex front end we lean heavily on client-first principles. And for everything in between we rely on a sane toolchain that allows us to mix and match Django with a front-end codebase that is clear and sensible to navigate.

Ok, first the basics: where to put stuff.

At a high level, we have JavaScript project a subfolder in the root of our larger Django project. We will use a folder called ./assets/ for the front-end source files.

The JavaScript project is where you'll do your front-end development—but remember Django will only work with the outputs generated by the bundler. So in addition to our ./assets/ directory, we'll also dump the outputs somewhere that Django's static files system can find them. A good default for this is an appropriately named root-level ./static/ folder.

Before the project setup, PLEASE READ THE FOLLOWING FIRST:


High Level Project Details:
A hybrid project of Django 5.1 backend paired with a React frontend (react-dom routing) implementing the shadcnUI library components. Additionally, we will use djangorestframework, drf-spectacular, and the OpenAPI client for our api. 
The project is stored in a root folder named V1 which contains a folder named trading_project which we cd into to get into in the working directory of our entire application.
Detailed descriptions of our project setup, backend, and frontend will be written below but first READ THE IMPORTANT INSTRUCUTIONS HERE: 


IMPORTANT INSTRUCTIONS/GUIDELINES CRITICAL LEVEL (numbering does NOT mean level importance, all are equally important): 
1. Enforce the DRY (Don't repeat yourself) philosophy in code writing, make sure everything is reusable and future proof meaning updating/changing code is easy without rewriting too much code.
2. For the views in the backend ONLY use class views no function based views additionally use generic views (as a base class or standalone) whenever applicable as to avoid writing too much bloat code.
3. For the frontend PRIMARILY use shadcnUI components (note that when downloading them in the CLI the base files are stored in a ui folder where they are lowercase), do not just import the default ones create your own versions of them for use in the application. Professional theme, sleek design and animations.
4. The application must support both light and dark modes and have a highly efficient dynamic layout that has a desktop (default) and mobile version (for smartphones in the future).
5. *** ALL BACKEND RELATED REQUESTS SHOULD BE HANDLED VIA THE DJANGO BACKEND NEVER THROUGH THE FRONTEND THIS IS CRUCIAL. The frontend is purely for displaying a UI and interacting with the backend, the Django backend should be responsible for all other tasks. Make sure to use the OpenAPI client and NEVER USE neither fetch nor axios.
6. Always prefer to incorporate built-in in Django functionality in the backend and only install packages when there is no other alternative.
7. Make all code as robust and feature rich as possible but avoid repetition and follow the DRY principle.
8. Add comprehensive error handling and security measures to the application (we will add https at the final stage of the project so no need now).
9. Every file you create/edit include the relative file path in comments at the top of the file
10.The platform is currently in development therefore having to sign in each time and managing accounts is unnecessary for most tests. Add a variable in the settings.py file called DEBUG_USER = False not include user aspects of the app and setting it to True includes it.
11. Make sure that the browser remembers the state at all times, I am not sure what this is called maybe sessions or cookies however you choose to implement it. Make sure that if a user reloads the page all their changes are saved at all times meaning refreshing or exiting does not reset the app. Add another constant in the settings.py file to enable refresh reset (i.e. no session tracking).
12. THIS IS GOING TO BE A PRODUCTION LEVEL COMMERCIAL PLATFORM, treat the project as such and build it in a scalable way with professional standards.
13. When applicable employ best practices such as inheritance, use of namespaces, etc.
14. ROUTING MUST BE THROUGH FRONTEND USING REACT DOM ROUTING.
15. Add an elaborate but easy to navigate logging folder (with subfolders for different areas of logging say for example when user signs up, when certain bugs occur or errors etc. so we can easily navigate our log files)
16. NEVER use the local storage for sensitive data such as user information/credentials or tokens.
17. I am using a windows machine and vs code editor

____________________

*** Project Setup:


Setup Initial File Structure:

V1
|	
|-- trading_project
|	├── manage.py
|	├── trading_project
|	│   ├── __init__.py
|	│   ├── settings.py
|	│   ├── urls.py
|	│   └── wsgi.py
|	├── myapp      <----- a normal Django app
|	│   ├── __init__.py
|	│   ├── models.py
|	│   ├── urls.py
|	│   └── views.py
|	├── assets     <----- our front-end project source
|	│   ├── javascript
|	│   └── styles
|	├── static     <----- our front-end project outputs (and other Django static files)
|	│   ├── css
|	│   ├── images
|	│   └── js  
|	└── templates  <----- our Django template files
|   		└── myapp
|
|------------ venv
|------------ requirements.txt



1. From the root of the V1 folder create a requirements.txt file containing all python packages to be used in our application (update this as needed in the future)

2. Now create a virtual environment using the command:
python -m venv venv

3. Activate the virtual environment by entering:
python .\venv\Scripts\activate (use tabs)

4. Install necessary python packages (must include Django) using:
pip install -r requirments.txt

5. Run the following command in the terminal to initialize our Django project:
django-admin startproject trading_project

5. Enter our working directory
cd trading_project

6. Then from the root of the django project:
C:\Asher Projects\Algorithmic Trading Platform\Version Control\V1\trading_project>

Perform the following commands in a new terminal (this will be for our node):
npm init -y
npm install webpack webpack-cli --save-dev

7. The first thing we do is install Babel (@babel/core), its webpack loader babel-loader and our two presets, all as development dependencies:
npm install --save-dev babel-loader @babel/core @babel/preset-env @babel/preset-react

8. Next we have to tell webpack to use this preset to process our files. This is done via a loader. We just need to add the following section to our webpack.config.js.

  module: {
    rules: [
      {
        test: /\.(js|jsx)$/,
        exclude: /node_modules/,
        loader: "babel-loader",
        options: { presets: ["@babel/preset-env", "@babel/preset-react"] }
      },
    ]
  }

In English the summary is: "use Babel's env and react presets to compile all .js and .jsx files that aren't inside the node_modules directory".

9. Install react and react-dom:
npm install --save react react-dom

10. NOTE: When we run the command (in the node terminal):
npm run dev

This will bundle all of our javascript files in the assets folder as specified in the webpack.config.js file:

const path = require('path');

module.exports = {
  entry: './assets/index.js',  // path to our input file
  output: {
    filename: 'index-bundle.js',  // output bundle file name
    path: path.resolve(__dirname, './static'),  // path to our Django static directory
  },
  module: {
    rules: [
      {
        test: /\.(js|jsx)$/,
        exclude: /node_modules/,
        loader: "babel-loader",
        options: { presets: ["@babel/preset-env", "@babel/preset-react"] }
      },
    ]
  }
};

(we will need this to be more robust later on so it will work for more files, we have to bundle files for use like this)

11. Additional Note: Every Django app that we will create should contain an api/ folder that will contain the serializers for our apps.

12. Note: Configure future app urls.py like this for example:

from rest_framework import routers
from . import views

urlpatterns = [
    # other urls here
]

router = routers.DefaultRouter()
router.register('api/employees', views.EmployeeViewSet)

urlpatterns += router.urls

*Checkpoint: Our Application environment and initial packages are configured and we may now begin development. 

____________________


*** Backend Development:

General:

- Backend type: Django 5.1 paired with djangorestframework and drf-spectacular(for better OpenAPI integration)
- Project name: trading_project
- Root location: C:\Asher Projects\Algorithmic Trading Platform\Version Control\V1\trading_project> (this will change once in production, this is for development only)
- Apps: User, DataManager, TradingAPI, Portfolio, Developer, Settings
- Packages: Stored in requirements.txt file
- Virtual environment: venv
- Database: Use Postrges 
- Routing: Use the Django rest framework Default API router for API requests from frontend.


User App: 
- Responsible for user registration, login, and storing account information (this is the base user this app contains no information other than what I wrote below).
- To register a user they must provide: 
{ first name, last name, email address(must be valid, send a OTP code to confirm email and process it), username (username must not be taken), password (8+ characters), reconfirm password when signing up, date of birth (verify 18+), broker details such as the brokerage, login credentials etc., must agree on terms and conditions of app usage and allow permissions to make trades on user behalf, THE USER MUST SELECT A SUBSCRIPTION TIER (STANDARD, PREMIUM, PREMIUM PLUS) THIS IS INTEGRAL FOR SIGNING UP (THEY MUST HAVE CONFIRMED PAYMENT VALIDATED IN ORDER TO CREATE AN ACCOUNT) SET THIS UP USING STRIPE FOR NOW }
- To login a user must provide: {username, password} if the user clicks forgot username/password send them an email to reset the username password
- If the user is 'Anonymous' or unauthenticated (i.e. hasn't signed up or logged in) they will be prompted to the hero page of the app when accessing the baseurl. If the user has logged in recently (once in the last two weeks) then that data is saved and when they access the page again they are auto logged in (note that there is no caching/data saved if the user explicitly logged out then whenever they access the page again they must sign in) and are redirected to their home page (called the command center). 
-  Every User has a foreign key to the Portfolio (will define below) responsible for all things related to the users investments.

Portfolio App:
- Responsible for storing, updating, getting, altering, and deleting data related to the users portfolio. 
- For example this is where statistics such as balance, risk, liquidity, buying power, margin, wins, losses, W/L ratio, All trades, and many more relevant statistics should be stored and accessible.
- Views that include but are not limited to a calendar that displays all trades on select days (boxes contain dollar amount / perc of portfolio at the time and are on a scale of red to green so that the more negative the more red and the more positive the more green there should be a weekly, monthly, and yearly view), A dashboard for statistics mentioned above with animated/interactive charts that display the data.
- Think of as many more additional statistics and features to include, remember robustness is key and there should be many features.
- A portfolio model should have a one to many relationship with portfolio models that are specific to options, stocks, forex, real estate, etc. (there will be many overlapping entries so create a base model that all others will be mixed in with /inherited these should be all common features).  The main portfolio model is linked to our User model via a one to one relationship delete on cascade. 
- Create seperate robust views for each type of portfolio and also for the main portfolio as well include all possible functionality.

Datamanager App:
- This app is responsible for handling various types of data requests and needs to be able to preform CRUD operations on our database. For example we need to setup a data source (for now make this the interactive brokers python ibapi client but make this versatile so in the future we will be able to switch to any provider, use JSON to achieve this I think it is most robust) component that is interchangeable for future, there are several scripts needed for this such as a live_bar_pipeline, live_ticker_pipeline, historical_data_pipeline (these are for stocks but include separate pipelines for Options, FOREX, CRYPTO, as well).  These type of pipelines should be for use of getting data from the database. We also need pipelines that can request new data from the data provider (under the condition that the requested data does not exist in the database) memory constraints and other limitations must be considered.  We need pipelines that can load data into different formats including but not limited to pandas data frames, csv, xlsx, text files.  We also need methods to query the databases for example what tickers are included, timeframes, intervals, etc. 
- We need this to work with both postgres and SQLite.
- Ensure solution is as feature-rich and robust as possible including all the functionalities we described and more.
- Make sure the databases are well structured and organized as this is of utmost importance
- MOST IMPORTANTLY WHEN DOWNLOADING NEW DATA BEFORE ADDING IT TO THE DATABASE ENSURE THE DATA IS THOROUGHLY CLEANED.
- This app has many implementations as it must be called in several parts of our platform such as charting, data exploration page, and in our command center for live trading.
- VERY IMPORTANT THE MOST IMPORTANT PART: THIS IS THE DATA THAT OUR MODELS WILL USE WHEN RUNNING, ENSURE THAT THEY HAVE HIGHEST PRIORITY FOR ALL REQUESTS.

TradingAPI App:
- This app is responsible for the following: it holds a default template of functions that are mandatory for any trading API. This template will be decorated by one of many decorator TradingAPI functions depending on what broker the user has an account for. For example, if the user has interactive brokers account we decorate the default template with @IB_User and this will modify all existing functionalities to work with the users select brokerage API.  Create the @broker_name decorators for all brokerages that you know their API but first and foremost make the most robust possible default tradingAPI template that has all functionalities for our platform to work. The tradingAPI is responsible for also routing account/portfolio information to the Portfolio App in addition to executing trades adding stop losses etc. (make this as robust as possible include all possible functionalities I cannot stress this enough).
- VERY IMPORTANT: The tradingAPI app will be responsible for a lot of the requests sent from the frontend to interact with the account/trades etc. make sure it is as optimized speedy as possible.

Developer App:

Within the developer mode, (Which will be a feature available only to premium tier users in the future but for now avoid authorization) create a model editor page that consists of the following structure:
* The default navbar component that is located on the top of the page that is viewable from all pages on the site, consisting of a logo and the phrase "Developer Mode" on the left side and all buttons towards the right hand side of the screen with options such as (Model Editor, Backtesting, Data Exploration, Model Leaderboards, Settings).
* A toggable side menu of drag and drop components that are contained in a tree structure (for example the tree is enter strategies, exit strategies, signal models, data loader, market scanner, environment conditions, custom, etc. where each can be shown or hidden like in a tree structure and in each category there can be subcategories or components we will change in the future) each component is a python function that I will have available in the backend somehow and the user must be able to drag and drop components from the menu which will animate grabbing and dragging it across the screen and there will be a count that appears for number of components within this menu once one is added to the main model in the builder panel. Add also a dropdown menu in there that is responsible for the selecting the current template being used (there should be a series of options such as default, advanced, custom, etc.) selecting a template will change create a premade structure of components in the panel which we will define below.
* A builder panel, grid whatever is most applicable to build a tree structure of components (components that were dragged here can be different colors shapes and sizes etc.) each component on this panel can be connected to others based on background logic that will be determined later. In this panel we should be able to create a type of visible graph tree structure which is actually a complete python application of a model. Add arrows between components that can have custom colors widths, labels etc. based on what components are connected and make sure the user can click and drag on the panel to view the model if it does not fit in the panel (make sure the panel is covering as much screen real estate as possible. Add a full screen button on the top right of the panel that the user can click and display the panel in full screen allowing them to better view the model tree they created (dragging and dropping should also still work here).  
* In a visible centered part on the bottom of the screen add a menu bar with buttons that for now are just going to be "compile", "save model", "backtest model" we might add more in the future. 
* There should be a small window where a user can see all of their created models from the past, clicking one will open their model in the editor where they can change its structure and save it. There should be version control support here so they can always revert/use previous versions. Similarly to the toggable sidebar this window will also employ a tree structure where we clicking the model name opens up a subdirectory of the models version along with the status of the model which changes color based on status ("beta", "alpha", whatever)   
* The compile button will preform a series of tests on the model to make sure it works and if a test is failed then the user will be alerted with a popup for example ("No signal strategy detected" etc.). After passing all tests the backend receives the request and compiles the model with all the components and saves it as an executable (this feature needs to make the model as some sort of file that can only be executed by the user but won't let them have any access to the code itself). After successful compilation the model is saved with a status that it is "beta" and the user should be able to see it in the models subdirectory in the created models window.
* The save button will save the current model (prompting save automatically tests the model in the background to see if it is compilable if it is then it is saved in the window as "not compiled" therefore won't be visible elsewhere in our platform, but if it fails some tests then there will be a popup stating "model is incomplete. save anyways?")
* The backtest button will only work if the model was compiled ie in beta version otherwise clicking it will result in an error popup stating "model must be compiled first". If the model was successfully compiled then clicking this button will send the user to the backtest page and automatically fill out the details in that page for this specified model which we will define in another conversation.
Some very important notes: Make sure to employ animations where necessary and use sleek layout design and nice fonts. There must be a dark and light theme both must be professional enterprise financial app level.

*NOTE: I have some code in tsx that I want in jsx attached to the message/in the project knowledge that I want you to use/update do not write from scratch and do not delete what currently is written maintain all the functionality I wrote and only then I will let you know what to do.


Settings App:

This will be meant for a settings page that will allow the user to:
- update their payment details
- delete their account
- change their password or email address (include verification)
- change their brokerage account details
- change certain UI aspects such as themes for example
- export account data to a csv or pdf format. The pdf must be very attractive and represent the company branding, both files should include things like wins, losses, profits, drawdowns, etc. it should display the information from their portfolios.  


Django Admin:
- Use Django unfold and Django import-export packages to make the Django admin page look modern and have more functionality.
- Add filters, search, etc. and make sure it works with all of our apps.
- Make the Django admin include visualizations of data such as user subscriptions rates, time spent on the app, signup rates, number of active users, ratings of the app, sentiment etc.
- Implement different groups with different permissions 

Production Wrapper:
For clarity this is the hero section and signup/login screens that must appear when the app is in production but this should not be required generally for use (while in development) of the application.  We still need to be able to access these screens during development but these will be mostly static pages.

Passing data from backend to frontend:
- Use a mix of Django templating (for dynamic data that is not heavy/impact performance) and providing the data via asynchronous APIs, using JavaScript and Django REST framework (DRF).
- When using the templating follow these steps:
1. In the Django view that serves our application we get the data we need.
2. We pass it to the template in a way that can be serialized as JSON.
3. We load the JSON into JavaScript and make it available to the front end.

In the Django template itself use the jscon_script template tag to serialize the data.
- When using the API approach use the OpenAPI client

Routing:

Handling URL routing on the back end
Since the client is handling all the heavy lifting, the server side of the setup is easy.

All that's needed is to add the following to your urls.py:

urlpatterns = [
    # this route catches the "naked" URL with no path specified. you can link to it in most places
    path(r'my-react-page/', views.MyReactView.as_view(), name='react_app'),  

    # this route catches any url below the main one, so the path can be passed to the front end
    path(r'my-react-page/<path:path>', views.MyReactView.as_view(), name='react_app_with_path'),
]
The only other caveat is to make sure your view can take in the appropriate argument. Class-based views will do this out of the box via the **kwargs argument, and function-based views can do it with a default parameter:

class MyReactView(TemplateView):
    template_name = 'react_app.html'

    def get_context_data(self, **kwargs):
        return {'context_variable': 'value'}

One thing worth pointing out is that Django doesn't do anything with the path at all! You don't even need to pass it to the template. That's because the JavaScript frameworks have their own way of extracting the path directly from the browser.


** Routing will be handled by the frontend like for example:

<Router basename='/my-react-page/'>
  <Switch>
    <Route path="/about">
      <About />
    </Route>
    <Route path="/users">
      <Users />
    </Route>
    <Route path="/">
      <Home />
    </Route>
  </Switch>
</Router>

Authentication:
- We will use the @login_required decorator or LoginRequiredMixin on the hybrid Django view serving our template.  Do not use local javascript storage for any security related tasks.
Use the built-in Django authentication make it work with the custom user.

Security:
Implement throttle limits to prevent DDOS attacks or any type of penetration attempts to the website. Ensure that all user data is encrypted including brokerage credentials.
Do not configure https yet as we will do this last.
Use a .env file to store all sensitive information and use the load_env function to load the environment variables.

*Checkpoint: Our Application backend and initial Django apps are complete, now move on to developing the frontend below. 

____________________


*** Frontend Development:

Here is our current packages.json file:

{
  "name": "trading_project",
  "version": "1.0.0",
  "main": "index.js",
  "scripts": {
    "test": "echo \"Error: no test specified\" && exit 1",
    "dev": "webpack --mode development --watch"
  },
  "keywords": [],
  "author": "",
  "license": "ISC",
  "description": "",
  "devDependencies": {
    "@babel/core": "^7.25.2",
    "@babel/preset-env": "^7.25.4",
    "@babel/preset-react": "^7.24.7",
    "babel-loader": "^9.2.1",
    "webpack": "^5.95.0",
    "webpack-cli": "^5.1.4"
  },
  "dependencies": {
    "lodash": "^4.17.21",
    "react": "^18.3.1",
    "react-dom": "^18.3.1"
  }
}


- Project name: trading_project
- Pages to create: 
Anonymous User (Not logged in) these pages are static: Hero Page, About Page, Pricing Page, Create an account/signup page (server focused using Django forms), Login Page (server focused using django forms) The hero page in this case is on the base url.

Authroized User (Logged In) these pages are heavily dynamic: Command Center Page, Portfolio Page, Performance Page, Settings Page, Developer Page (This should only be accessible if the user is a premium plus user but for testing purposes this should be disabled for now and accessible)

- Downloaded packages: react, react-dom, lucide icons, webpack, babel
- Premade components/widgets: Incorporate shadcn (javascript not typescript) and tradingview widgets into the frontend. 
- Package manager: npm
- API: Use the OpenAPI to interact with our django backend
- Use django templates for pages that have little to no dynamic components such as the login/signup and settings pages.

We will incorporate Django templates and our bundled JavaScript files like this for example:

{% extends "myapp/base_template.html" %}
{% block content %}
  <!-- div that the JavaScript framework will render in -->
  <div id="js-framework-home"></div>
  <!-- bundle file with our JavaScript application logic -->
  <script src="{% static 'js-bundle.js' %}"></script>
{% endblock content %}

And then, separately, in our JavaScript codebase, we mount our React app using the "js-framework-home" div id from the template.

import React from 'react';
import ReactDOM from "react-dom";
import EmployeeApplication from "./App";  

ReactDOM.render(
  // Our main React application component, which we've imported from another file
  <EmployeeApplication />,
  // Gets rendered to the <div> we defined in our Django template using the shared id
  document.getElementById('js-framework-home')
);
The React side of things. This file should get compiled as the entry-point in your webpack build pipeline into js-bundle.js


There are multiple tsx files that I have already created however I will need you to convert them to jsx for our use, maintain all functionality do not shorten the files or remove anything. First convert all of these files from the project knowledge and then show me how to incorporate them into our desired structure. 

- Only after doing this then alter the files for use in our project in the structure that I have wrote.

Once you have done all of this let me know and I will give you more instructions.


